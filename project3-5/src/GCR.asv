function [result] = GCR(M, b, x, maxIter, errorThres)
% Generalized Conjugate Residual
% M,b,x-Mx = b
% x0-the initial x
% errorThres-the boundary of error
% maxIter-the maximum GCR iteration 

[m,n] = size(M);

if (m ~= n)
    disp ('matrix M is not squart');
    result = x;
    return
end

if (norm(b,2) == 0)
    result = zeros(size(x));
    return
end

maxIter = min(maxIter,m);

r0 = b - M * x;
r = r0;
iter = 0;

if M' == M % symmetirc case
    disp('symmetric matrix');
    p = r;
    for j = 1 : m
        Mpj = M * p;
        % stop criteria
        if (iter >= maxIter || norm(Mpj,2) == 0 )
            break;
        end
        a = (r' * Mpj) / (Mpj' * Mpj);
        x = x + a * p;
        if (norm(a*p,2) < errorThres)
            break;
        end
        r = r - a * Mpj;
        beta = ((M * r)' * Mpj); % / (Mpj' * Mpj);
        p = r - beta * p;
        iter = iter + 1;
    end
    fprintf('(%d/%d)\n',j,m);
else % non-symmetric case
%     disp('non-symmetric matrix');    
    Mp = zeros(m, maxIter);
    p = zeros(m, maxIter);
    p(:,1) = r;
    for j = 1:m
        % stop criteria
        normMp = norm(Mp(:,j),2);
        if (normMp ~= 0)
            p(:,j) = p(:,j) / normMp;
        end
        Mp(:,j) = M * p(:,j);
        
        if (iter >= maxIter || norm(Mp(:,j),2) == 0)
            break;
        end
%         a = (r' * Mp(:,j)) / (Mp(:,j)' * Mp(:,j));
%         x = x + a * p(:,j);
        a = (r' * Mp(:,j));
        x = x + a * p(:,j);
        if ( norm(a * p(:,j),2) < errorThres)
            break;
        end
        r = r - a * Mp(:,j);
        p(:, j+1) = r;                                
        for i = 1:j
%             beta = ((M * r)' * Mp(:,i)) / (Mp(:,i)' * Mp(:,i));
%             p(:,j+1) = p(:,j+1) - beta * p(:,i);
            p(:,j+1) = p(:,j+1) - ((Mp(:,j))' * Mp(:,i)) * p(:,i);
        end
        iter = iter + 1;
    end
    fprintf('(%d/%d)\n',j,m);
end
% return value 
result = x;



